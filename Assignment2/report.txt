@Πρόγραμμα:
	Σύστημα Ελέγχου Πυρκαγιάς (ΣΕΠ)

@Περιγραφή:
	Ένα command line πρόγραμμα που προσομοιώνει την εγκατάσταση, διαχείριση και ανανέωση μονάδων από sensors
ελέγχου πυρκαγιάς. Το πρόγραμμα παρέχει ένα εύχρηστο interface το οποίο επιτρέπει στο χρήστη να εισάγει κτήρια
και τοποθεσίες στο κάθε κτηριο όπου θα εγκατασταθούν μονάδες ΕΠ. Το πρόγραμμα επίσης παρέχει εύκολη πρόσβαση στα
δεδομένα των sensors, καθώς και τη δυνατότητα επεξεργασίας του αριθμου τοποθεσιών δυναμικά κατά την εκτέλεση του
προγράμματος. Τέλος, το προγραμμα συνδυάζοντας τα δεδομένα των sensor υπολογίζεται εάν υπάρχει πυρκαγιά, 
λαμβάνοντας υπ'όψη το id του κτηριου και της συγκεκριμένης τοποθεσίας.

@Δομή Προγράμματος:
	Ως μοντέλο επικοινωνίας μεταξύ κλάσεων/αντικειμένων χρησιμοποιήθηκε αποκλειστικά Composition. Επέλεξα
εσκεμμένα να αποφύγω οποιαδήποτε μορφή Inheritance με σκοπό να διατηρήσω ένα καθαρό και επεκτάσιμο API κάτι που
προφανώς το inheritance model δεν προσφέρει. Χρησιμοποίησα πολλαπλής πρόσβασης accessors (this.getObj1().getObj2().getValue())
για την επεξεργασια του global state των αντικειμένων, και διαμέρισα τα δεδομένα σε κλάσεις, και τις συναρτήσεις
σε state, χρησιμοποιώντας και lambdas σε κάποιες περιπτώσεις. Τα παραπάνω χαρακτηριστικά δίνουν ιδιάιτερα 
πλεονεκτήματα στο API του προγράμματος, συγκεκριμένα:

1) Ενισχύουν τη σωστή χρήση του encapsulation σε αρκετα μεγάλο βαθμό.
2) Επιτρέπουν την επαναχρησιμοποίηση κώδικα.
3) Δημιουργούνται κλάσεις που είναι σχεδόν ολοκληρωτικά package-private (Καλύτερο encapsulation).
4) Επιτρέπουν την αλλαγή του implementation class χωρίς την αλλαγή των composition data, καθώς τα composed
   δεδομένα έχουν δηλωθεί ως instance variables που δείχνουν σε αντικείμενα.

Το πρόγραμμα αποτελείται από (Building) object για τη διαχείρηση των κτηρίων και την αποθήκευση της λίστας των 
τοποθεσιών: (Location) objects. Κάθε Location εχει δύο αντικείμενα (Temperature) και (Brightness) ως sensors
καθώς και ένα (TimeKeeper) object που διαχειρίζεται την μεταβολή του χρόνου στο πρόγραμμα. Οι Temperature και
Building κλάσεις έχουν από ενα (Reliability) object που διαχειρίζεται την μεταβολή της αξιοπιστίας των sensors.
Υποθετικά, η συνολική αξιοπιστία των sensor set κάθε τοποθεσίας είναι άριστη, και σταδιακά μειώνεται με τη πάροδο του χρόνου.
Αυτή είναι η δομή του API, την οποία χρησιμοποιεί η κλάση (SEPInterface). Εδώ βρίσκεται το σύνολο της λογικής:
η δημιουργία κτηρίων, τοποθεσιών, η επεξεργασία τους, οι υπολογισμοί για την ύπαρξη φωτιάς. Η SEPInterface επίσης
συμπεριλαμβάνει "helper" κλάσεις, συγκεκριμένα: την (RandomGenerator) για τη δημιουργια τυχαιων integer και double
τιμών για να ανανεώσει τους sensors, και την (Writer) για τη δημιουργία και τη διαχείρηση του αρχείου "measures.txt".
Τέλος, η κλαση (SEP) εφαρμόζει την main συναρτηση, η οποία χρησιμοποιεί το functionality της SEPInterface στη
δημιουργία του βασικού μενου.

@Πως να τρέξετε το πρόγραμμα:
	Βασική προυπόθεση για επιτυχές compilation είναι η χρήση της Java 8+ (jvm 1.8) λόγω της χρήσης των lambdas
και functional interfaces).

Το παρακάτω script εκτελεί επιτυχώς compilation του προγράμματος σε Windows, Linux/*nix, MacOS, εφόσων τα αρχεία του
java interpreter και javac compiler βρίσκονται στο (%PATH%), ($PATH) και (Home) αντίστοιχα για κάθε λειτουργικό.
Eπίσης τα αρχεία πρέπει να βρίσκονται στον ίδιο φακελο με το script.

---------------------
javac *.java
java SEP
---------------------

@Προβλήματα με τον κώδικα:
	Δεν υπάρχει κάποιο πρόβλημα με τον κώδικα, το πρόγραμμα εκτελεί κάθε ζητούμενο της άσκησης χωρίς λάθη,
και το μοντέλο είναι επεκτάσιμο και αποφεύγει τα περισσότερα Exceptions, συγκεκριμενα

1) Στο Scanner object χρησιμοποιώ τα δεδομένα του χρήστη ως strings ακόμα και αν ζητάω αριθμούς: ("1" αντι για 1 ..).
   Ετσι προσπερνάω τα περισσότερα Integer Exceptions σχετικα με τα data conversions (Integer::parse και λοιπες συναρτήσεις)
   Στις ιδιαίτερες περιπτώσεις όπου ο χρήστης δίνει το κενό, χρησιμοποιώ ενα generic Exception catch block στο οποιώ απλά
   επαναλαμβάνω το loop.
2) To composition-driven API που περιέγραψα παραπάνω δημιουργεί ελάχιστα λάθη στην επικοινωνία μεταξύ των αντικειμένων
3) Στην λογική του προγράμματος χρησιμοποίησα συναρτησιακό προγραμματισμό για τις περισσότερες μεθόδους, και κλήσεις
   της μορφής: .findAny().orElse(null) και Objects.requireNonNull() οι οποίες αποτρέπουν τα περισσοτερα nullPointerExceptions.
4) Τα μόνα προβλήματα που μπορεί να προκύψουν είναι λογικά λάθη σε ιδιαίτερες περιπτώσεις (Δεν έκανα Unit Testing για ελέγξω)